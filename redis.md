# redis

## NOSQL数据库的概述

NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。 

NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。

**Nosql适用的场景：**

对数据高并发的读写

海量数据的读写

对数据高可扩展性的

**Nosql不适用的场景:**

需要事务支持

基于sql的结构化查询存储，处理复杂的关系,需要即席查询



### memcache与redis的区别：

**memcache:**

 很早出现的NoSql数据库

数据都在内存中，一般不持久化

支持简单的key-value模式，支持类型单一

一般是作为缓存数据库辅助持久化的数据库

**redis:**

几乎覆盖了Memcached的绝大部分功能

 数据都在内存中，支持持久化，主要用作备份恢复

除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。

一般是作为缓存数据库辅助持久化的数据库

**Mongodb**

高性能、开源、模式自由(schema free)的**文档型数据库**

 数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘

 虽然是key-value模式，但是对value（尤其是**json**）提供了丰富的查询功能

支持二进制数据及大型对象

可以根据数据的特点**替代RDBMS** ，成为独立的数据库。或者配合RDBMS，存储特定的数据。

## redis常见的五种数据类型

### 1、简单动态字符串（SDS）

redis是一个键值对型的数据库，即key-value型，创建一个简单的字符串，key保存字符串的名字，value保存的是字符串的值

SDS的定义如下所示：

![image-20210719203329344](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210719203329344.png)



#### sds与c字符串的区别

1、常数复杂度获取字符串的长度

因为对于普通的字符串的时候，我们需要一个个元素去遍历，才能获取得到字符串的长度，但是对于redis来说，有一个len属性保存的就是字符串的常度，直接获取即可。

2、杜绝缓冲区溢出

![image-20210719203713119](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210719203713119.png)



如上图所示，这是普通的字符串数组，如果我们想要在数组s1的末尾追加一段字符串的话，加入没有分配足够大的存储空间的话，那么就会使得s1的空间溢出到s2的范围，覆盖到s2的区间上，那么就会造成数据的错误，如下图所示，新添加的cluster就会将s2覆盖。

![image-20210719203935644](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210719203935644.png)

而redis里面的简单动态字符串会预先判断空间是否足够，不够的话就会预先分配空间，然后再进行拼接字符。如下图所示：

![image-20210719204238907](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210719204238907.png)

具体的分配策略如下介绍

3、减少字符串变化时的内存重分配次数

3.1、因为redis是作为数据库，经常有大量的访问量，所以如果修改的次数少的话还接受，但是一般都是几百万的并发量，所以需要减少修改的次数，那么就需要使用预先分配的策略，第一种分配策略就是：

如果对sds进行修改后的的大小小于1MB的话，那么就需要分配同样大小的空间，解释如下：

假如sds修改后的大小为15字节，那么程序就会将free属性的大小也设置为15字节，这时候表示，sds存储的字符的长度是15字节，剩余的空间为15字节。那么总的长度为：15+15+1=31字节，多了一个字节是因为字符末尾的'\0'需要一个字节存储。

另外一种分配就是：如果修改后的大小大于1MB的话，那么直接分配1MB的剩余空间，例如修改后的字节的大小为10MB，那么free就需要设置为1MB，

这样总的字节的大小为：10MB+1MB+1字节

3.2、惰性空间释放

![image-20210719205307693](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210719205307693.png)

如上所示的字符串，假如我要删除X和Y，那么删除后的空间，sds并不会立即释放，而是等到下一次再利用，即将释放的位置的空余空间加到free那里

![image-20210719205451372](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210719205451372.png)

4、二进制安全

C语言的字符串必须符合某种编码的方式，例如ASCII码，但是sds对于存储的数据都是按照二进制来存储，无关数据的格式问题

5、sds兼容部分的C字符串函数

可以不用自己设计函数，直接调用c语言的函数即可



用途：

### 2、链表

链表和链表结点的实现

![image-20210719205907870](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210719205907870.png)

![image-20210719205939132](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210719205939132.png)

head:表头指针

tail：表尾指针

dup：复制链表结点所保存的值

free：释放链表结点所保存的值

match：查看链表结点保存的值是否和另外一个输入的值相等

![image-20210719210226704](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210719210226704.png)

### 3、字典

字典的底层实现就是利用哈希表来实现的

哈希的定义如下图所示:

![image-20210719210406871](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210719210406871.png)

![image-20210719210421789](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210719210421789.png)

![image-20210719210810465](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210719210810465.png)

![image-20210719210824204](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210719210824204.png)

![image-20210719210854414](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210719210854414.png)

哈希算法：





## redis的过期设置

### 1、定时删除

定时删除对内存最友好，但是对cpu不友好，因为删除的话需要频繁的执行，删除键的操作会占用很多cpu时间，对服务器的吞吐量和性能造成影响

### 2、惰性删除

惰性删除对cpu最友好，但是对内存不友好，因为服务器只会在取出键的时候判断键是否过期，然后再进行删除。

![image-20210721090948480](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210721090948480.png)

### 3、定期删除

每隔一段时间进行一次删除，定期删除执行的太频繁就会退化为定时删除，删除的时间间隔很久就退化为惰性删除

### AOF、RDB和复制功能对过期键的处理

#### RDB

**生成RDB文件：**

在执行save或者bgsave命令的时候会创建一个新的RDB文件，但是过期的键不会保存到RDB文件中。

**载入RDB文件**

如果是以主服务器模式运行，那么载入RDB文件的时候，过期键会被忽略

如果是以从服务器模式运行，那么载入RDB文件的时候，过期键不会被忽略

#### AOF

**AOF文件的写入**

当服务器以AOF模式运行的时候，过期键不会产生影响，即会被忽略

**AOF文件的重写**

过期的键不会被写入

#### 复制

1、主服务器在删除一个键的时候，会向从服务器发送一个DEL命令，告知从服务器删除这个键

2、从服务器在没有收到主服务器的DEL命令的时候，就算客户端请求这个键，照样会给客户端发送这个键值

3、当从服务器收到DEL命令的时候，那么就删除这个键，这样主从服务器中都没有这个键。

## RDB持久化

两个命令实现redis持久化：

1、SAVE命令：是一个阻塞的命令，直到RDB文件创建完成的时候，否则服务器处于阻塞状态，不能处理请求。

2、BGSAVE命令：不是阻塞的命令，他会创建一个子进程来实现RDB文件的操作，而主进程继续接收其他的请求

因为AOF持久化的更新频率比RDB文件的执行频率多，所以服务器在执行的时候，会优先执行AOF持久化

![image-20210721092659687](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210721092659687.png)

SAVE执行时的服务器状态：所有的请求将会被阻塞

BGSAVE执行时的服务器状态：

1、客户端发送的SAVE命令被拒绝

2、客户端发送的BGSAVE命令被拒绝，因为同时执行两个一样的命令会形成竞争条件

3、BGSAVE和BGRWRITEAOF命令不能同时执行，若BGSAVE命令在执行，那么BGRWRITEAOF会等BGSAVE执行完再执行；若BGRWRITEAOF在执行，则BGSAVE命令会被拒绝



#### dirty计数器和lastsave属性

dirty计数器记录的是距离上一次成功执行save命令或者bgsave命令之后，服务器的数据库状态修改了多少次

last save命令记录的是unix时间戳，记录服务器上一次成功执行save或者bgsave命令的时间

## AOF持久化

RDB持久化是通过记录数据库的当前状态和键值对的方式实现

AOF持久化是通过记录数据库的执行写命令来实现

### AOF文件的重写

AOF文件因为保存了很多的文件写命令后，会变得很大，所以对服务器的性能的执行影响很大，所以需要进行重写，缩小AOF文件的大小。

具体就是：新建一个AOF文件，然后去读取当前数据库的状态和未过期的键值对，然后将对这些键值对的写操作的命令保存为一条命令，这样的话就会变得很方便，如果有保存过期信息的键值对，也需要重写。

**AOF文件后台重写**

因为一个文件可能会写的时间很长，所以AOF在重写时候会造成执行命令的线程被长时间阻塞，但是redis是单线程执行的方式，所以在执行操作的时侯，服务器就无法处理新来的任务的请求。

解决方法：redis将服务器的重写放入到子进程执行，即后台执行

子进程在执行AOF文件重写的时候，主进程继续处理新来的请求，而且使用子进程可以避免使用锁的情况下，保证数据的安全。

**子进程在重写期间，如果主进程对数据进行了修改，那么就会使得AOF文件保存的数据不一致**

解决方法：

除了设置AOF缓冲区外，还设置一个AOF重写缓冲区，当子进程执行的时候，重写缓冲区就会被启动，子进程对AOF缓冲区的数据进行读取，然后在这期间主线程的操作就会保存到AOF缓冲区中，当子进程执行完AOF缓冲的写操作时，就会发送一个信号告诉主进程，主进程就会将AOF重写缓冲区的数据加到AOF缓冲区之中，如此便可以保证数据的同步和一致性。

![image-20210721094940047](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210721094940047.png)

## 复制

主从服务器的复制功能的实现

### 旧版的复制实现

主要包括同步和命令传播阶段两个步骤：

1、同步

![image-20210721102643455](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210721102643455.png)

2、命令传播功能

当主从服务器实现同步以后，如果主服务器修改了某一个值，那么就会发送修改的命令给从服务器，从而继续保持一致

3、旧版的缺陷：

![image-20210721102842873](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210721102842873.png)

在断线后连接服务器，那么复制会从头开始，所以效率比较低

### 新版复制的实现

![image-20210721103001948](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210721103001948.png)

部分重复制的实现功能：

1、复制偏移量

主从服务器都会维持一个复制偏移量，当主服务器给每次向从服务器发送N个字节的数据的时候，主服务器的复制偏移量就会加N，如果从服务器接收到N个字节的时候，就将自己的复制偏移量加N，这样就可以保证数据一致。

2、复制积压缓冲区

当主服务器向从服务器发送一个数据的时候，还会将命令加入到一个复制积压缓冲区之中，因此，主服务器的复制积压缓冲区就会保持一些最近执行的命令。当从服务器重新连接上之后，从服务器将自己的复制偏移量发送给服务器，如果offset之后的数据还在积压缓冲区，那么就执行部分重同步操作，否则就执行完整重同步操作。

3、服务器ID

每个redis服务器都会有自己的运行ID，当从服务器对主服务器进行初次复制的时候，主服务器将会自己的运行ID发送给从服务器，从服务器会将这个ID保存起来，当从服务器断线重新连接上的时候，从服务器将保存的ID发送给主服务器：

若主服务器的id和从服务器保存的id一致，那么就尝试进行部分重同步操作

若不一致的话，就执行完整重同步操作。

## 哨兵（sentinel）

哨兵系统可以监视任意多个主服务器以该主服务器的从服务器。

监视的步骤主要有：

1、当主服务器下线的时候，sentinel会从主服务器的一个从服务器中挑选一个作为新的主服务器

2、向原先的主服务器的所有从服务器发出复制命令，让他们称为新的主服务器的从服务器

3、sentinel还会监视已经下线的主服务器，如果重新上线的话，那么将这个上线的服务器设置为新的主服务器的从服务器。



**初始化服务器**

因为sentinel所执行的任务与redis服务器的不一样，所以在初始化的时候和redis服务器不一致，不需要加载RDB文件或者AOF文件



选出新的从服务器的步骤：

1、删除列表中所有下线的服务器或者短线的服务器，保证列表中的服务器都是正常连接的

2、删除列表中最近五秒内没有回复过零头sentnel的INFO命令的从服务器，保证剩余的服务器在最近都是进行过通信的。

3、删除所有的与已经下线的主服务器连接断开超过down-after-millseconds*10毫秒的从服务器，down-after-millseconds选项指定了判断主服务器下线所需要的时间，而删除断开时长超过down-after-millseconds×10毫秒的服务器，可以保证列表中的服务器都没有过早地与主服务器断开。



哨兵模式是一种特殊的模式，是一个独立的进程，作为进程，他会独立地运行，所以需要单独开一个进程来运行。

使用一个哨兵进程会服务器进行监控，可能会出现问题，因为一个哨兵挂了，那就没办法了，所以我们可以使用多个哨兵进行监控，哨兵之间还会进行监控，这样就形成了多哨兵模式。

设置：

1、配置哨兵配置文件sentinel.conf

```bash
# sentinel monitor 被监控的名称 host port 1
sentinel monitor myredis 127.0.0.1 6379 1
```

后面的这个数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机

2、启动哨兵

启动配置文件

优点：

1、哨兵集群，基于主从复制模式，所有的主从复制的优点他都有

2、主从可以切换，故障可以转移，系统的可用性就会很好

3、哨兵就是主从模式的升级，手动到自动，更加健壮

缺点：

1、redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦

2、实现哨兵模式的配置其实很麻烦，里面有很多的选择



## 集群

默认情况下每一台redis服务器都是主服务器。

### 搭建集群

要搭建几个节点，就复制几个redis的配置信息，然后修改相应的信息即可。主要修改以下几个部分：

1、端口号

2、pid信息

3、log信息

4、dump信息

上述几个地方都修改为相应的端口对应的信息即可。

### 主从复制的操作

每一个节点在设置之前都是默认为主节点，所以需要在相应的窗口下，发送命令SLAVEOF ip port，ip指的是要连接的主节点的ip，端口也是相应的主节点的端口号

那么就可以通过：info replication 查看当前节点的信息，看是否状态变为从节点即可。

这里的配置方法是临时的，如果需要永久的配置的话，需要在配置文件里面，将replicaof<masterip><masterport>这里的ip和port设置为主节点的ip和port，这样的话，打开redis服务器，就默认为从机。

**细节**

主机可以写 ，从机不可以写，主机中的所有的信息和数据，从机中都有





节点：集群都是一个个的节点组成，通过cluster meet命令来让每一个节点进行握手，从而实现集群

集群的数据结构

clusternode保存了一个节点的当前状态，比如节点创建的时间，节点的名字、接待你当前的配置纪元、节点的ip地址和端口等

每个节点都会使用一个clusterNode来记录自己的状态，并未集群中的所有其他的节点都创建一个相应的clusterNode的结构，来记录其他节点的状态

![image-20210722085211253](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722085211253.png)

### cluster MEET命令的实现

1、节点A会首先为节点B创建一个clusterNode结构，并将该结构添加到自己的clusterState.Nodes的字典里；

2、节点A根据客户端发来的CLUSTER MEET命令的IP和端口，向节点B发送一条MEET命令。

3、如果一切顺利的话，节点B收到MEET消息，会为A创建一个clusterNode的结构，并添加到自己的clusterState.nodes的字典里面

4、节点B向节点A发送一条PONG消息

5、若A接收到这条消息，说明B收到了A的MEET命令

6、之后A向B发送一条PING消息

7、、如果一切顺利的话，节点B收到节点A的PING消息，由此可以判断节点A收到了节点B的PONG消息，由此握手完成。

![image-20210722085233201](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722085233201.png)

**槽指派**

集群的整个数据库被分成16384个槽，数据库中的每一个键都属于槽中的一个，集群中的每一个节点可以出处理0个或者最多16384个槽

若集群中的所有的槽都被处理，那么集群就处于上线状态，否则只要有一个没被处理，集群就属于下线状态。

可以通过CLUSTER ADDSLOTS命令向节点指派槽

**传播节点的槽指派信息**

一个节点除了保存自己的槽记录以外，还会将自己的slots数组（即记录处理的槽的数组）信息发送给其他节点，让其他节点了解自己的处理的槽

![image-20210722085248732](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722085248732.png)

其他节点在收到另外的节点发来的槽信息的时候，会将这个数组保存到对应节点的clusternode结构中，这样集群中每个节点都会知道数据库中的16384个槽被分配到了什么地方。

**在集群中执行命令**

当集群中所有的槽都被指派完时，集群就处于上线状态，此时客户端就可以向集群发送消息了

当客户端向节点发送与数据库的状态有关的命令的时候，接受命令的节点会计算出命令要处理的数据库属于哪个槽，并检查这个槽是否指派给自己

1、若指派的槽是在当前节点中，那么节点直接执行命令

2、如果键指派的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED的错误，指引客户端转向正确的节点，并再次发送想要执行的命令

![](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722090637263.png)

**计算键属于哪个槽**



![image-20210722090655851](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722090655851.png)

**判断槽是否由当前节点处理**

![image-20210722090900950](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722090900950.png)

![image-20210722091022986](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722091022986.png)

如上图所示，若计算出来的槽号是2022，那么查找2022所属于的clusterNode数组，发现其指向myself，那么就直接处理

若计算出来的槽号是6257，查找相应的clusterNode数组，发现其指向不是myself，那么节点7000就会去查找clusterNode指向的cluster结构，发现ip为127.0.0.1，端口号为7001，那么就向客户端返回MOVED命令。

**MOVED命令**

错误格式为：

MOVED<slot><ip><port>    

slot为键所在的槽，ip和port是负责处理槽slot的节点的ip地址和端口号

![image-20210722091532856](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722091532856.png)

![image-20210722091540834](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722091540834.png)

**重新分片**

redis的重新分片的操作就是可以将任意数量的已经指派给某个节点的槽重新指派给新的节点，并且相关槽所属的键值对也会从源节点指向目标节点

重新分片可以在线执行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理请求。

![image-20210722092704619](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722092704619.png)

**ASK错误**

![image-20210722092843673](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722092843673.png)

![image-20210722093025529](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722093025529.png)

### 复制与故障转移

redis集群中的几点分为主节点与从节点，主节点用于处理槽，从节点则用于复制某个主节点，并在被复制的主节点下线的时候，代替下线的主节点，继续执行命令。

![image-20210722093553097](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722093553097.png)

若当前节点7000是主节点，7004和7005是7000的从节点，7000负责处理的槽是从0到5000，假如此时7000下线的话，那么集群中的其他几个主节点会从7004和7005中重新选一个作为主节点处理0到5000的槽，假如选举7004作为主节点，那么7005将会成为7004的从节点，并且如果7000重新上线的话，继续变成7004的从节点。

#### 故障检测

![image-20210722094707305](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722094707305.png)

![image-20210722094635386](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722094635386.png)

![image-20210722094720585](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722094720585.png)

![image-20210722094731610](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722094731610.png)

![image-20210722094749416](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722094749416.png)

### 消息

![image-20210722095043237](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722095043237.png)

![image-20210722095051818](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722095051818.png)

#### MEET、PING、PONG消息的实现

![](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722095302057.png)

#### FAIL消息的实现

![image-20210722095501402](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722095501402.png)

## 发布与订阅

redis的发布于订阅功能由PUBLISH、SUBSCRIBE、PSUBSCRIBE实现

通过SUBSCRIBE命令，客户端可以订阅一个或者多个频道，从而成为这些频道的订阅者，每当有其他客户端向被订阅者发送消息的时候，频道的所有订阅者都会接收到消息

![image-20210722095841401](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722095841401.png)

如上图所示i，A、B、C三个客户端都订阅了news.it频道，那么当客户端向这个频道发消息的时候，所有的订阅的客户端都能收到

## 事务

### 事务的实现

事务的实现主要经历一下三个阶段：

1、事务开始

2、命令入队

3、事务执行

### 事务的开始

MULTI命令的执行标志着事务的开始，会将执行该命令的客户端由非事务状态转移到事务状态。

### 命令入队

当一个客户端处于非事务状态的时候，这个客户端发送的命令会立即被服务器执行

当客户端处于事务状态的时候，服务器会根据客户端发来的不同的命令来执行不同的操作：

1、若客户端发送的命令是EXEC、DISCARD、WATCH、MULTI四个命令中的一个，则服务器会立即执行命令

2、若客户端发送的是上面的四个命令之外的命令，那么服务器不会立即执行命令，而是将命令放到一个事务队列中，然后向客户端返回QUEUED回复。

![image-20210722101858353](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722101858353.png)

事务队列是一个先进先出的队列结构，所有的命令都会按顺序执行

![image-20210722102338426](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722102338426.png)

### 执行事务

当一个处于事务状态的客户端向服务器发送EXEC命令的时候，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，然后将执行的结果返回给客户端。

### WATCH命令的实现

WATCH命令是一个乐观锁，它可以在EXEC命令执行之前，监视任意数量的数据库，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过，如果是的话，服务器拒绝执行事务，并向客户端返回代表事务执行失败的空回复。

![image-20210722103129659](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722103129659.png)

#### 使用watch命令监视数据库

![image-20210722103330447](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722103330447.png)

![image-20210722103341064](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722103341064.png)

#### 监视机制的触发

![image-20210722103812200](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722103812200.png)

#### 判断事务是否安全

![image-20210722103852745](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722103852745.png)

### 事务的ACID性

#### 原子性

事务具有原子性指的是，数据库将事务中的多个操作当作一个整体来执行，服务器要么执行所有的操作，要么一个操作都不执行。

![image-20210722104211363](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722104211363.png)

#### 一致性

![image-20210722104321115](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722104321115.png)

![image-20210722104709600](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722104709600.png)

![image-20210722104721786](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722104721786.png)

![image-20210722104818229](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722104818229.png)

#### 隔离性

![image-20210722104849501](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722104849501.png)

#### 耐久性

![image-20210722104912265](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722104912265.png)

![image-20210722104921614](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210722104921614.png)

## redis缓存穿透与雪崩

### 缓存穿透（查不到）

概念：用户想要查询一个数据，发现redis内存数据库里面没有，也就是缓存没有命中，于是向持久层数据库查询，发现也没有，于是本次查询失败，当用户数量很多的时候，缓存都没有命中，于是都是去请求持久层的数据库，这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。

![image-20210723090349046](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210723090349046.png)

#### 解决方案：

1、规范key过滤：

规范key的命名，并且统一缓存查询的入口，在入口处进行对key的命名规范检测，例如公司规定，查询的，命名规范是：公司名_项目名-redis开头，那么不符合这个规范的就全部过滤掉，这样可以避免大量的恶意攻击。

2、缓存空值

如果用户查到的数据为空，那么我们就将这个空值加到缓存中，后面来查询的虽然得不到数据，但是能查询到一个空值，也不会立马对持久层的数据库进行访问，减少压力，但是设置空值有时候也会给服务器带来压力。

3、加锁

根据key从缓存中获取到的value为空时，先锁上，再去查DB将数据加载到缓存，若其它线程获取锁失败，则等待一段时间后重试，从而避免了大量请求直接打到DB。单机可以使用synchronized或ReentrantLock加锁，分布式环境需要加分布式锁，如Redis分布式锁

4、布隆过滤器

我们想这样一个问题，如果想判断某个元素是不是在一个集合里，一般做法是将集合中所有的元素保存起来，然后通过比较确定，比如HashMap。但是随着集合中元素的增加，数据量超大时，我们需要的存储空间也越来越大，甚至超过服务器内存，这时我们就不能再用HashMap等数据结构了。

布隆过滤器就出场了，它的空间效率非常好，它是一个二进制向量，每一位存放的是0或1，**初始时默认为0**，长下面这样：

![](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210723091841707.png)

当一个元素加入到集合中的时候，我们可以通过k个哈希函数来计算这个元素对应的哈希下表，例如加入一个元素9，那么经过哈希函数k1，k2，k3，分别得到哈希值为1、2、3，那么我们就将下表为1、2、3的位置的数组设置为1

![image-20210723091902009](C:\Users\tz\AppData\Roaming\Typora\typora-user-images\image-20210723091902009.png)

如果现在有一个元素X来访问，如何知道他存不存在于缓存中呢，我们先对他进行哈希计算，得到对应的三个哈希值，如果这三个哈希值对应的下标的数组为1，说明这个数可能存在于缓存中（可能存在是因为多个值计算得到的哈希值可能存在冲突），假设经过三个哈希函数计算得到的哈希值为：4、6、9，那么我们就查看上面的数组下标为4、6、9的位置是否为1：

1、 如果都是1，则元素Y可能存在于集合中，为什么说可能呢——hash碰撞，不同的两个元素，经过同样的hash函数，计算出来的值，从概率上来讲是有可能重复的。所以这也是布隆过滤器最大的缺点，存在误判率。

2、如果不全是1，则元素Y肯定不存在

当它说某个 key 不存在时，key一定不存在；当它说某个 key 存在时，key 可能存在

**布隆过滤器是怎样解决缓存穿透的？**

 预先将所有缓存数据的key存放到布隆过滤器中，当一个查询请求过来的时候，先判断这个key在布隆过滤器中是否存在？

```bash
> 如果不存在，直接返回提示，都不用去查缓存更不用说持久层数据库了；

> 如果存在，则去查缓存，但我们知道布隆过滤器判断存在有一定的误判率，这里我是这样理解的，如果这个误判率针对你们的业务场景是可被接受的则可以忽略，另外我们在用Guava实现布隆过滤器的时候可以指定误判率不超过多少，你可以指定一个可被你接受的值。再或者，因为布隆过滤器可以过滤掉绝大多数的恶意key，针对少部分的漏网之鱼，我们可以在缓存层面使用功能上面说过的缓存空值或加锁的方案。
```
### 缓存击穿（大量的访问热点）

缓存击穿和缓存穿透不一样！

说缓存击穿之前，我们先来了解一个概念——热点key，某个访问非常频繁，访问量非常大的一个缓存key，我们叫做热点key。**（微博热搜导致微博服务器宕机）**

缓存击穿是指某个热点key在失效的瞬间（一般是缓存时间到期），持续的大并发请求穿破缓存，直接打到数据库，就像在一个屏障上凿开了一个洞，造成数据库压力瞬间增大，这就是缓存击穿。

#### 解决方案

 1、设置热点key永不过期

2、加锁，根据热点key从缓存中获取到的value为空时，先锁上，再去查DB将数据加载到缓存，若其它线程获取锁失败，则等待一段时间后重试，从而避免了大量请求直接打到DB。单机可以使用synchronized或ReentrantLock，分布式需要加分布式锁，如Redis分布式锁。【为了不阻塞对其他key的请求，此处可以用热点key来加锁】。



### 缓存雪崩

缓存雪崩是指缓存由于某些原因整体或者大量失效，导致大量请求打到后端数据库，从而导致数据库崩溃，整个系统崩溃，发生灾难。

导致缓存整体或大量失效的场景一般有：

1、缓存服务宕机，如Redis集群彻底崩溃；

  2、在某个集中的时间段内，系统预加载的缓存集中失效了；

**双十一的时候停掉一些服务，例如退款等**

#### 解决方案

1、redis高可用

这个思想的含义就是：虽然redis可能挂掉，那就多增加几台redis，这样一台挂掉以后其他的还可以继续工作，其实就是搭建集群（异地多活）

2、限流降级

思想：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量，比如对某一个key只允许一个线程来查询数据和写缓存，其他线程等待

3、数据预热

就是在正式部署前，先把数据预先访问一遍，这样大部分的可能大量访问的数据就会加载到缓存中，在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀一点。

